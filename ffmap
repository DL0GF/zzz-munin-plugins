#!/usr/bin/perl -w

use strict;
use warnings;
use utf8;    # this script is written in utf8

use lib $ENV{'MUNIN_LIBDIR'};
use Munin::Plugin;

use Data::Dumper;
use JSON;
use LWP::Simple;

# some munin init
need_multigraph();

# data
my $nodes_ref;

# all nodes and clients
my $sum_clientcount  = 0;
my $node_count       = 0;
my $sum_online_nodes = 0;

# clients on specific nodes
# TODO  make this list available over config
my %node_id = (
    'balkonx' => ['12:fe:ed:2b:15:ae'],
    'balkony' => [ 'c6:4a:00:fc:22:06', 'c2:4a:00:fd:22:06' ],
);

my %personal_node_clients = (
    'balkonx' => 0,
    'balkony' => 0,
);

# firmware versions
my %firmware_count = ( 'undef' => 0 );
my %firmware_name  = ( 'undef' => 'undef' );

# models
my %model = ( 'undef' => 0 );

# TODO  make URL configurable
sub get_node_data {
    my $content = get('http://map.md.freifunk.net/nodes.json');
    die 'Could not get it!' unless defined $content;

    $nodes_ref = decode_json($content);
}

sub all_nodes_clients {
    foreach my $node ( @{ $nodes_ref->{'nodes'} } ) {
        if (!(     $node->{'flags'}->{'gateway'}
                || $node->{'flags'}->{'client'}
            )
            )
        {
            # number of online/offline nodes and client count
            $node_count++;
            $sum_clientcount += $node->{'clientcount'};
            if ( $node->{'flags'}->{'online'} ) { $sum_online_nodes++ }

            # firmware versions (not wanted for gateways and clients)
            if ( defined $node->{'firmware'} ) {
                my $fieldname
                    = clean_fieldname( 'v' . $node->{'firmware'} );
                if ( exists( $firmware_count{$fieldname} ) ) {
                    $firmware_count{$fieldname}++;
                }
                else {
                    $firmware_count{$fieldname} = 0;
                }
                if ( not exists $firmware_name{$fieldname} ) {
                    $firmware_name{$fieldname} = $node->{'firmware'};
                }
            }
            else {
                $firmware_count{'undef'}++;
            }

            # models (this is not wanted for gateways and clients)
            if ( defined $node->{'model'} ) {
                if ( exists( $model{ $node->{'model'} } ) ) {
                    $model{ $node->{'model'} }++;
                }
                else {
                    $model{ $node->{'model'} } = 0;
                }
            }
            else {
                $model{'undef'}++;
            }
        }
    }
    print {*STDERR} Dumper(%firmware_count);
    print {*STDERR} Dumper(%firmware_name);
}

sub personal_nodes_clients {
    foreach my $node ( @{ $nodes_ref->{'nodes'} } ) {
        foreach my $node_name ( keys %node_id ) {
            foreach my $id ( @{ $node_id{$node_name} } ) {
                if ( $node->{'id'} eq $id ) {
                    print {*STDERR} "found " . $id . "\n";
                    $personal_node_clients{$node_name}
                        = $node->{'clientcount'};
                }
            }
        }
    }
}

# get all data
get_node_data();

# process all nodes/clients graph
all_nodes_clients();

# main
if ( $ARGV[0] and $ARGV[0] eq "config" ) {
    print "multigraph ffmap_all_nodes\n";
    print "graph_title Freifunk Nodes and Clients\n";
    print "graph_args --base 1000 --lower-limit 0\n";
    print "graph_scale no\n";
    print "graph_category freifunk\n";
    print "graph_vlabel #\n";
    print "offline.label offline\n";
    print "offline.type GAUGE\n";
    print "offline.draw AREASTACK\n";
    print "offline.min 0\n";
    print "offline.colour COLOUR2\n";
    print "offline.info Number of offline nodes.\n";
    print "online.label online\n";
    print "online.type GAUGE\n";
    print "online.draw AREASTACK\n";
    print "online.min 0\n";
    print "online.colour COLOUR0\n";
    print "online.info Number of online nodes.\n";
    print "clients.label clients\n";
    print "clients.type GAUGE\n";
    print "clients.min 0\n";
    print "clients.colour COLOUR1\n";
    print "clients.info Sum of clients over all nodes.\n";

    print "multigraph ffmap_personal_nodes\n";
    print "graph_title Alex' Freifunk Knoten\n";
    print "graph_args --base 1000 --lower-limit 0\n";
    print "graph_scale no\n";
    print "graph_category freifunk\n";
    print "graph_vlabel Clients\n";
    print "balkonx.label balkonx\n";
    print "balkonx.draw AREASTACK\n";
    print "balkonx.min 0\n";
    print "balkony.label balkony\n";
    print "balkony.draw AREASTACK\n";
    print "balkony.min 0\n";

    print "multigraph ffmap_firmware_versions\n";
    print "graph_title Freifunk Node Firmware Versions\n";
    print "graph_args --base 1000 --lower-limit 0\n";
    print "graph_scale no\n";
    print "graph_category freifunk\n";
    print "graph_vlabel Nodes\n";

    foreach my $key ( sort keys %firmware_count ) {
        print "${key}.label " . $firmware_name{$key} . "\n";
        print "${key}.draw AREASTACK\n";
        print "${key}.min 0\n";
    }

    exit 0;
}

my $offline_nodes = $node_count - $sum_online_nodes;
print "multigraph ffmap_all_nodes\n";
print "online.value $sum_online_nodes\n";
print "offline.value $offline_nodes\n";
print "clients.value $sum_clientcount\n";

# process personal nodes/clients graph
personal_nodes_clients();
print "multigraph ffmap_personal_nodes\n";
print "balkonx.value $personal_node_clients{'balkonx'}\n";
print "balkony.value $personal_node_clients{'balkony'}\n";

# firmware
print "multigraph ffmap_firmware_versions\n";
foreach my $key ( sort keys %firmware_count ) {
    print "${key}.value " . $firmware_count{$key} . "\n";
}

# vim: set ft=perl et sts=0 ts=4 sw=4 sr:
